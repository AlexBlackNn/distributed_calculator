### Это пет проект, так что порты на БД и брокере не закрыты, также не стал настраивать nginx в качестве обратного прокси. 

Для запуска, больше ничего делать не нужно
```bash
bash run.demo.sh 
```


### Задача
Пользователь хочет считать арифметические выражения. Он вводит строку 2 + 2 * 2 и хочет получить в ответ 6. Но наши операции сложения и умножения (также деления и вычитания) выполняются "очень-очень" долго. Поэтому вариант, при котором пользователь делает http-запрос и получает в качетсве ответа результат, невозможна. Более того: вычисление каждой такой операции в нашей "альтернативной реальности" занимает "гигантские" вычислительные мощности. Соответственно, каждое действие мы должны уметь выполнять отдельно и масштабировать эту систему можем добавлением вычислительных мощностей в нашу систему в виде новых "машин". Поэтому пользователь, присылая выражение, получает в ответ идентификатор выражения и может с какой-то периодичностью уточнять у сервера "не посчиталость ли выражение"? Если выражение наконец будет вычислено - то он получит результат. Помните, что некоторые части арфиметического выражения можно вычислять параллельно.

Front-end часть

GUI, который можно представить как 4 страницы

    Форма ввода арифметического выражения. Пользователь вводит арифметическое выражение и отправляет POST http-запрос с этим выражением на back-end. Примечание: Запросы должны быть идемпотентными. К запросам добавляется уникальный идентификатор. Если пользователь отправляет запрос с идентификатором, который уже отправлялся и был принят к обработке - ответ 200. Возможные варианты ответа:
        200. Выражение успешно принято, распаршено и принято к обработке
        400. Выражение невалидно
        500. Что-то не так на back-end. В качестве ответа нужно возвращать id принятного к выполнению выражения.
    Страница со списком выражений в виде списка с выражениями. Каждая запись на странице содержит статус, выражение, дату его создания и дату заверщения вычисления. Страница получает данные GET http-запрсом с back-end-а
    Страница со списком операций в виде пар: имя операции + время его выполнения (доступное для редактирования поле). Как уже оговаривалось в условии задачи, наши операции выполняются "как будто бы очень долго". Страница получает данные GET http-запрсом с back-end-а. Пользователь может настроить время выполения операции и сохранить изменения.
    Страница со списком вычислительных можностей. Страница получает данные GET http-запросом с сервера в виде пар: имя вычислительного ресурса + выполняемая на нём операция.

    Требования:
    Оркестратор может перезапускаться без потери состояния. Все выражения храним в СУБД.
    Оркестратор должен отслеживать задачи, которые выполняются слишком долго (вычислитель тоже может уйти со связи) и делать их повторно доступными для вычислений.


Back-end часть

Состоит из 2 элементов:

    Сервер, который принимает арифметическое выражение, переводит его в набор последовательных задач и обеспечивает порядок их выполнения. Далее будем называть его оркестратором.
    Вычислитель, который может получить от оркестратора задачу, выполнить его и вернуть серверу результат. Далее будем называть его агентом.

Оркестратор
Сервер, который имеет следующие endpoint-ы:

    Добавление вычисления арифметического выражения.
    Получение списка выражений со статусами.
    Получение значения выражения по его идентификатору.
    Получение списка доступных операций со временем их выполения.
    Получение задачи для выполения.
    Приём результата обработки данных.


Агент
Демон, который получает выражение для вычисления с сервера, вычисляет его и отправляет на сервер результат выражения. При старте демон запускает несколько горутин, каждая из которых выступает в роли независимого вычислителя. Количество горутин регулируется переменной среды.


### Необходимые требования:
0. [x]  Существует Readme документ, в котором описано, как запустить систему и как ей пользоваться.
-   Это может быть docker-compose, makefile, подробная инструкция - на ваш вкус
- Если вы предоставляете только http-api, то
- в Readme описаны примеры запросов с помощью curl-a или любым дргуми понятными образом
- примеры полны и понятно как их запустить
Этот пункт дает 10 баллов. Без наличия такого файла - решение не проверяется.

```bash
cd infra
docker-compose -f docker-compose.demo.yaml up
```

Из корня проекта накатываем миграции
```bash
cd orchestrator
go run ./cmd/migrator/postgres  --migrations-path=./migrations 
```

Примечание: в случае ошибки миграций, подождать когда все контейнеры запустяться
```
panic: EOF
goroutine 1 [running]:
main.main()
.../sso/cmd/migrator/postgres/main_postgres.go:43 +0x29c
exit status 2
```

Примеры запросов: 
[swagger](http://localhost:8080/swagger/index.html#/)

1. [x] Программа запускается и все примеры с вычислением арифметических выражений корректно работают - 10 баллов
   
Есть небольшой интеграционный тест в папке tests 
   
2. [x] Программа запускается и выполняются произвольные примеры с вычислением арифметических выражений - 10 баллов

Есть валидация нечетного количества скобок, типа **(2*2+3** и нескольких подряд идущих знаков 2/*3.  
Выражения вида **2+-3** НЕ валидное и для его расчетов следует использовать **-3+2**

3. [x] Можно перезапустить любой компонент системы и система корректно обработает перезапуск (результаты сохранены, система продолжает работать) - 10 баллов

   Результаты храняться в БД
   Сообщения и очереди имеют настройки персистентности подробнее [тут](https://www.rabbitmq.com/tutorials/tutorial-two-go.html)

4. [x] Система предосталяет графический интерфейс для вычисления арифметических выражений - 10 баллов
   Примеры запросов:
   [swagger](http://localhost:8080/swagger/index.html#/)

5. [x] Реализован мониторинг воркеров - 20 баллов
   
   Мониторинг воркеров сделан с помощью запроса к брокеру сообщений, о подключенных воркерах 
   http://localhost:8080/swagger/index.html#/ /monitoring/worker Получение количества активных воркеров
   
   Увеличить количество воркеров.
   ```bash
   cd infra
   docker-compose -f docker-compose.demo.yaml scale worker=2
   ```   

6. [x] Реализован интерфейс для мориторинга воркеров - 10 баллов

   Интерфейс воркеров сделан на базе брокера сообщений. Логин: guest, Пароль: guest
   http://localhost:15672/#/

7. [x] Вам понятна кодовая база и структура проекта - 10 баллов (это субъективный критерий, но чем проще ваше решение - тем лучше).
    Сделано с помощью паттерна Репозиторй.
   
8. [х] У системы есть документация со схемами, которая наглядно отвечает на вопрос: "Как это все работает" - 10 баллов 
   Схемы лежат в папке docs

9. [ ] Выражение должно иметь возможность выполняться разными агентами - 10 баллов
   Количество воркеров можно задавать командой 

   ```bash
   cd infra
   docker-compose -f docker-compose.demo.yaml scale worker=2
   ```
   Можно посмотреть с помощью handler мониторинга воркеров, что появилось 2 воркера, которые будут считать параллельно РАЗНЫЕ выражения

   **Разбивки одного выражения на несколько и расчета его параллельно НЕТ**



### Локальный запуск 

# Окружение развёртывания программного обеспечения - локально

#### Запуск
1. Переходим в папку с инфраструктурой и запускаем docker-compose
``` bash 
cd infra
docker-compose up
```

2. Из корня проекта накатываем миграции
```bash
go run ./cmd/migrator/postgres  --migrations-path=./migrations 
```
Примечание: в случае ошибки, подождать когда все контейнеры запустяться
```
panic: EOF
goroutine 1 [running]:
main.main()
.../sso/cmd/migrator/postgres/main_postgres.go:43 +0x29c
exit status 2
```

3. Запускаем приложение локально
```bash
cd orchestrator
go run ./main.go --config=./config/local.yaml
```

Генерация swagger
```bash
cd orchestrator
go generate ./...
```

[swagger](http://localhost:8080/swagger/index.html#/)


eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJlbWFpbCI6Imx1bmFyYXRoQHJpcHBpbi5uZXQiLCJleHAiOjE3MTM0Njg2MjYsInRva2VuX3R5cGUiOiJhY2Nlc3MiLCJ1aWQiOjI0fQ.4Z07pCvO6ohZLm6NCJhSoofW453YUHzcSeDwTdQTkb4